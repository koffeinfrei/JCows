/*
 * Copyright 2006 Project JCows.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jcows.model.core;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URL;
import java.net.URLClassLoader;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.Map;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.axis.types.URI.MalformedURIException;
import org.apache.log4j.Logger;
import org.jcows.JCowsException;
import org.jcows.model.vc.ParamListItem;
import org.jcows.model.vc.VCMapper;
import org.jcows.system.Properties;

/**
 * All functionality that somehow need to interact with {@link java.lang.Class Class} 
 * object are gathered in this class. This means that pretty much everything herein
 * has something to do with <strong>Reflection</strong>.<br/>
 * <code>ClassHelper</code> provides the methods that construct new instances for the
 * classes and methods that we use for invoking the web services. Furthermore it provides
 * the methods for constructing parameter lists that are needed for the operations
 * of the web service.  
 * 
 * @author Alexis Reigel (alexis.reigel@jcows.org)
 * @version $LastChangedRevision:234 $, $LastChangedDate:2006-11-09 09:58:57 +0000 (Thu, 09 Nov 2006) $
 */
public final class ClassHelper {
  
  private static final Logger LOGGER = Logger.getLogger(ClassHelper.class);
  
  private URLClassLoader m_jarLoader;
  private VCMapper m_vcMapper;
  
  public ClassHelper(URLClassLoader jarLoader) throws JCowsException{
    m_jarLoader = jarLoader;
    this.m_vcMapper = VCMapper.getInstance();
  }
  
  /**
   * Returns true if the specified {@link java.lang.Class Class} implements 
   * the specified interface.
   * 
   * @param cl the {@link java.lang.Class Class} object.
   * @param toFind the name of the potential Interface.
   * @return true if the specified {@link java.lang.Class Class} implementes the
   *         specified interface, false otherwise. 
   * @throws JCowsException
   */
  public boolean hasInterface(Class cl, String toFind) throws JCowsException{
    for (Class c : cl.getInterfaces())
      try{ if (c.equals(Class.forName(toFind))) return true; }
      catch(ClassNotFoundException e){
        throw new JCowsException(Properties.getMessage("error.ClassNotFoundException"), e);
      }
    
    return false;
  }
  
  /**
   * Returns true if the {@link java.lang.Class Class} extends the specified superclass.
   * 
   * @param cl the {@link java.lang.Class Class} object.
   * @param toFind the name of the maybe superclass
   * @return true if the specified {@link java.lang.Class Class} extends the
   *         specified class.
   * @throws JCowsException
   */
  public boolean hasSuperclass(Class cl, String toFind) throws JCowsException{
    Class superclass = cl.getSuperclass();
    while ( superclass != null ) {
      try{ if (superclass.equals(Class.forName(toFind))) return true; }
      catch(ClassNotFoundException e){
        throw new JCowsException(Properties.getMessage("error.ClassNotFoundException"), e);
      }
      cl = superclass;
      superclass = cl.getSuperclass();
    }
    return false;
  }  
  
  /**
   * Returns an array of strings representing the parameter names 
   * (as they appear in the method declaration). The names are being
   * extracted from the method definition imported from the
   * source file of the specified Class. The source files are taken
   * from the jar file generated for the current web service. This means
   * that only classes are supported that belong to the web service itself, i.e.
   * are classes generated by the wsdl2java parser. Additionally we should 
   * support the axis types too as those classes are supported too (besides the
   * standard Java types). But as there are 30 classes each having 2-4
   * constructors we don't support that here (we don't have the sources 
   * available and don't want to have to switch between about 120 cases 
   * in this method).
   * 
   * @param cl the {@link java.lang.Class Class} which contains the specified method.
   * @param methodName a String value, the name of the method.
   * @param paramTypes an array of strings, the names of the 
   *        parameters of the specified method.
   * @return an array of strings containing the parameter names.
   */
  public String[] getParamNames(Class cl, String methodName, String[] paramTypes)
      throws JCowsException {
    
    LOGGER.debug("Getting Parameter Names of Method '" + methodName + "'...");
    
    /* create the regular expression */
    StringBuffer regex = new StringBuffer(".*");
    regex.append(methodName);
    regex.append("\\s*\\(");

    for (String param : paramTypes) {
      regex.append("\\s*");
      // escape '[' and ']'
      regex.append(param.replace("[", "\\[").replace("]", "\\]"));
      regex.append(" ([_\\w]+)\\s*,");
    }

    // initialize the paramNames array to default values
    String[] paramNames = new String[paramTypes.length];
    for (int i = 0; i < paramNames.length; ++i)
      paramNames[i] = paramTypes[i]; // default label is type

    regex.delete(regex.length() - 1, regex.length()); // remove last ,
    regex.append(".*");

    LOGGER.debug("Regex: " + regex + "<");

    Pattern pattern = Pattern.compile(regex.toString(), 
        Pattern.MULTILINE | Pattern.DOTALL);

    /*
     * read whole file into stringbuffer (line by line doesn't work, as method
     * defs. can span over multiple lines
     */
    String javaFile = cl.getName().replaceAll("\\.", "/") + ".java";
    LOGGER.debug("Javafile: " + javaFile);
    
    //InputStream in = m_jarLoader.getResourceAsStream(javaFile);
    /* Java bug workaround
     * "URLClassLoader fails to reload resources from dynamically 
     * changed jar-files"
     * (http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6487095)<br/>
     * Resources from a jar file are cached (as opposed to classes). 
     * In the case of a recompilation of the jarfile we get an error. 
     */
    File file = new File(m_jarLoader.getURLs()[0].getFile() + "!/" + javaFile);
    InputStream in = null;
    try {
      URL url = file.toURI().toURL();
      url = new URL("jar", url.getHost(), url.toString());
      URLConnection conn = url.openConnection();
      conn.setDefaultUseCaches(false);
      in = url.openStream();
    }
    catch (IOException e) {
      return paramNames;
      //throw new JCowsException(Properties.getMessage("error.IOException")
      //    + Properties.getMessage("error.noSuchFileInWSJarfile"), e);
    }
    
    StringBuffer content = new StringBuffer();
    
    if (in != null) {
      try {
        byte[] buf = new byte[0xFFFF];
        int len;
        while ((len = in.read(buf)) > 0) {
          content.append(new String(buf, 0, len));
        }
        in.close();
      }
      catch (IOException e) {
        throw new JCowsException(Properties.getMessage("error.IOException")
            + Properties.getMessage("error.noSuchFileInWSJarfile"), e);
      }
      
      Matcher matcher = pattern.matcher(content.toString());
      if (matcher.matches()) {
        for (int i = 0; i < paramNames.length; ++i) {
          paramNames[i] = matcher.group(i + 1);
          LOGGER.debug("Parameter name: " + matcher.group(i + 1));
        }
        return paramNames;
      }
    }
    return paramNames;
  }
  
  
  /**
   * Returns a list containing {@link org.jcows.model.vc.ParamListItem}s 
   * with the items extracted from a the fields of a class.
   * Returns a list with default values for the request.
   * 
   * @param arguments an array of {@link java.lang.Class Class} objects.
   * @param labels an array of strings.
   * @param values an array of {@link java.lang.Object Object}s.
   * @return a list containing paramListItems.
   * @throws JCowsException
   */
  public List<ParamListItem> getParamListFromFields(
      Class[] arguments, String[] labels, Object[] values) throws JCowsException{
    List<ParamListItem> list = new ArrayList<ParamListItem>(arguments.length);
    for (int i = 0; i < arguments.length; ++i){
      list.add(getParamListItemFromFields(arguments[i], labels[i], values[i]));
    }
    return list;
  }
  
  /**
   * Returns a {@link org.jcows.model.vc.ParamListItem} 
   * with the values extracted from the fields of a class.
   * This methods extracts with <strong>Reflection</strong> all instance
   * fields from the specified {@link java.lang.Class Class} and adds its
   * names and values to the list.
   * 
   * @param cl a {@link java.lang.Class Class} object to be mapped 
   *        to its corresponding <strong>Visual Component</strong> type.
   * @param label the label of the component.
   * @param value the value of the component.
   * @return the new {@link org.jcows.model.vc.ParamListItem}
   * @throws JCowsException
   */
  public ParamListItem getParamListItemFromFields(
      Class cl, String label, Object value) throws JCowsException{
    boolean isArray = cl.isArray();
    // set cl to its componenttype if cl is an array
    if (isArray){
      cl = cl.getComponentType();
    }
    
    // get the mappings for the parameter types
    Map<String, String> mapping = m_vcMapper.getMapping(cl.getName());    
    
    // field item type (or array)
    if (mapping.get(VCMapper.ELEMENTNAME_ITEMTYPE).equals(VCMapper.ITEMTYPE_FIELD)){
       return new ParamListItem(mapping.get(VCMapper.ATTRIBUTENAME_DATATYPE), cl.isPrimitive(),
          label, value, isArray);
    }
    // container item type
    else if (mapping.get(VCMapper.ELEMENTNAME_ITEMTYPE).equals(VCMapper.ITEMTYPE_CONTAINER)){
      Field[] fields = cl.getDeclaredFields();
      
      Vector<Class> types = new Vector<Class>();
      Vector<String> labels = new Vector<String>();
      Vector<Object> values = new Vector<Object>();
      
      try{
        for (Field field : fields){
          field.setAccessible(true);
          // only involve non-static fields
          // and exlude fields starting with "__" (axis generated)
          if ((field.getModifiers() & Modifier.STATIC) == 0
              && !field.getName().startsWith("__")){
            values.add(field.get(value));
            // if value is null, we just take the empty string as it doesnt 
            // matter anyway for displaying an empty value
            if (values.lastElement() == null) 
              values.set(values.size() - 1,  "");
            types.add(field.getType());
            labels.add(field.getName());
          }
        }
      }
      catch(IllegalAccessException e){
        throw new JCowsException(Properties.getMessage("error.IllegalAccessException"), e);
      }
      
      return new ParamListItem(getParamListFromFields(
          types.toArray(new Class[0]), labels.toArray(new String[0]), 
          values.toArray(new Object[0])), label, cl);
    }
    
    return null;//TODO exception or handle in getParamList
  }
  
  /**
   * Returns a list containing {@link org.jcows.model.vc.ParamListItem ParamListItem}s 
   * with the items extracted from a constructor.
   * Returns a list with default values for the request.
   * 
   * @param arguments an array of {@link java.lang.Class Class} objects.
   * @param labels an array of strings.
   * @return a list containing {@link org.jcows.model.vc.ParamListItem ParamListItem}s.
   * @throws JCowsException
   */
  public List<ParamListItem> getParamListFromConstructor(
      Class[] arguments, String[] labels) throws JCowsException{
    List<ParamListItem> list = new ArrayList<ParamListItem>(arguments.length);
    for (int i = 0; i < arguments.length; ++i){
      list.add(getParamListItemFromConstructor(arguments[i], labels[i]));
    }
    return list;
  }
  
  /**
   * Returns a {@link org.jcows.model.vc.ParamListItem} 
   * with the values extracted from a constructor. 
   * This method extracts with <strong>Reflection</strong> the parameters
   * from a constructor and adds its names to the list.
   * 
   * @param cl a {@link java.lang.Class Class} object to be mapped 
   *        to its corresponding <strong>Visual Component</strong> type.
   * @param label the label of the component.
   * @return a {@link org.jcows.model.vc.ParamListItem}.
   * @throws JCowsException
   */
  public ParamListItem getParamListItemFromConstructor(
      Class cl, String label) throws JCowsException{
    boolean isArray = cl.isArray();
    // set cl to its componenttype if cl is an array
    if (isArray){
      cl = cl.getComponentType();
    }
    
    // get the mappings for the parameter types
    Map<String, String> mapping = m_vcMapper.getMapping(cl.getName());    
    
    // field item type (or array)
    if (mapping.get(VCMapper.ELEMENTNAME_ITEMTYPE).equals(VCMapper.ITEMTYPE_FIELD)){
      String value = mapping.get(VCMapper.ELEMENTNAME_DEFAULTVALUE);
      return new ParamListItem(mapping.get(VCMapper.ATTRIBUTENAME_DATATYPE), cl.isPrimitive(),
          label+" ("+cl.getSimpleName()+")", (isArray)? new Object[]{value} : value, isArray);
    }
    // container item type
    else if (mapping.get(VCMapper.ELEMENTNAME_ITEMTYPE).equals(VCMapper.ITEMTYPE_CONTAINER)){
      Constructor[] constructors = cl.getDeclaredConstructors();
      int constructorIndex = getConstructorIndex(cl, constructors);
      Class[] params = constructors[constructorIndex].getParameterTypes();

      String[] paramTypes = new String[params.length];
      for (int i = 0; i < params.length; ++i)
        paramTypes[i] = params[i].getName();
      
      String[] labels = getParamNames(cl, cl.getSimpleName(), paramTypes);
      return new ParamListItem(getParamListFromConstructor(params, labels), label+" ("+cl.getSimpleName()+")", cl);
    }
    
    return null;//TODO exception or handle in getParamList
  }
  
  /**
   * Constructs an argument list from a list containing 
   * {@link org.jcows.model.vc.ParamListItem ParamListItem}s
   * used for "actually" invoking a method.
   * 
   * @param list the list containing the {@link org.jcows.model.vc.ParamListItem ParamListItem}s.
   * @return an array containing the values
   */
  public Object[] constructArguments(List<ParamListItem> list) throws JCowsException{
    Object[] args = new Object[list.size()];
    
    for (int i = 0; i < args.length; ++i){
      switch(list.get(i).getItemtype()){
        case ParamListItem.ITEMTYPE_FIELD:
        //args[i] = list.get(i).getValue()[0];
        //break;
        case ParamListItem.ITEMTYPE_ARRAY:
          args[i] = list.get(i).getValue();
        break;
        case ParamListItem.ITEMTYPE_CONTAINER:
          Class cl = list.get(i).getContainerComponentType();
          Object[] containerArgs = constructArguments(list.get(i).getList());
          // create a new instance of the "container" class with the
          // arguments that we get from the paramListItem
          args[i] = getNewInstance(cl, containerArgs);
        break;
      }
    }
    
    return args;
  }
  
  /**
   * Constructs a default argument list for the current settings (i.e. for the
   * currently set operation of the web service).<br/>
   * This method is used for constructing a list for a dummy request.
   * 
   * @return an array of {@link java.lang.Object Object}s corresponding to the argument list
   * @throws JCowsException
   */
  public Object[] constructArguments(Class[] arguments) throws JCowsException{
    Object[] args = new Object[arguments.length];
    for (int i = 0; i < args.length; ++i){
      args[i] = getNewInstance(arguments[i]);
    }
    //if (args.length == 0) return null;
    return args;
  }
  
  /**
   * Creates a new instance of a {@link java.lang.Class Class} with a defined set of 
   * arguments. <br/>
   * This method gets the appropriate constructor and 
   * invokes it with the arguments. 
   * 
   * @param cl the {@link java.lang.Class Class} object to be instantiated.
   * @param arguments the argument array containing. 
   * @return a new instance of the specified class.
   * @throws JCowsException
   */
  public Object getNewInstance(Class cl, Object[] arguments) throws JCowsException{ 
    try {
      Constructor[] constructors = cl.getDeclaredConstructors();
      int constructorIndex = getConstructorIndex(cl, constructors);
      constructors[constructorIndex].setAccessible(true);
      return constructors[constructorIndex].newInstance(arguments);
    }
    catch (SecurityException e) {
      throw new JCowsException(Properties.getMessage("error.SecurityException"), e);
    }    
    catch(IllegalAccessException e){
      throw new JCowsException(Properties.getMessage("error.IllegalAccessException"), e);
    }
    catch(InstantiationException e){
      throw new JCowsException(Properties.getMessage("error.InstantiationException"), e);
    }
    catch(InvocationTargetException e){
      throw new JCowsException(Properties.getMessage("error.InvocationTargetException"), e);
    }
    catch(IllegalArgumentException e){
      throw new JCowsException(Properties.getMessage("error.IllegalArgumentException"), e);
    }
  }
  
  /**
   * Creates a new instance of a {@link java.lang.Class Class}.<br/>
   * Recursively treats complex classes (i.e. constructors with multiple and non
   * Java class arguments). This method creates for each argument an instance
   * with a defined default value.
   * 
   * @param cl the {@link java.lang.Class Class} to be instantiated.
   * @return a new instance of the class.
   * @throws JCowsException
   */
  public Object getNewInstance(Class cl) throws JCowsException{
    int defaultNumValue = 1; // 1 works in more cases than 0
    try{
      Constructor[] constructors = cl.getDeclaredConstructors();
      // set all non-public constructors accessible
      for (Constructor c : constructors)
        c.setAccessible(true);

      if (cl.isPrimitive()){
        if (cl.equals(boolean.class)) return false;
        if (cl.equals(char.class)) return ' ';
        if (cl.equals(byte.class)) return (byte)defaultNumValue;
        if (cl.equals(short.class)) return (short)defaultNumValue;
        if (cl.equals(long.class)) return (long)defaultNumValue;
        if (cl.equals(float.class)) return (float)defaultNumValue;
        if (cl.equals(double.class)) return (double)defaultNumValue;
        return defaultNumValue; //int
      }
      if (cl.isArray()){
        // TODO: doesn't work in all cases, we have a problem if component type is not 
        // instantiable without getNewInstance
        //if (cl.getComponentType().isPrimitive())
          return Array.newInstance(cl.getComponentType(), 1); // 2
        //else return (new Object[]{getNewInstance(cl.getComponentType())});
      }
      if (constructors.length == 0)
        return cl.newInstance();
      if (constructors.length == 1 && constructors[0].getParameterTypes().length == 0)
          return cl.newInstance(); // TODO: if 1 constructor is not default constructor
      
      /* all in SOAP supported Java types (arrays, primitive types see above) */
      
      // standard Java classes
      if (cl.equals(String.class)) return "1";
      if (cl.equals(Date.class)) return new Date();
      if (cl.equals(Calendar.class)) return new GregorianCalendar();
      if (cl.equals(BigInteger.class)) return BigInteger.valueOf(defaultNumValue);
      if (cl.equals(BigDecimal.class)) return new BigDecimal(defaultNumValue);
      
      // wrapper classes
      if (cl.equals(Boolean.class)) return new Boolean(false);
      if (cl.equals(Byte.class)) return new Byte((byte)defaultNumValue);
      if (cl.equals(Short.class)) return new Short((short)defaultNumValue);
      if (cl.equals(Integer.class)) return new Integer(defaultNumValue);
      if (cl.equals(Long.class)) return new Long(defaultNumValue);
      if (cl.equals(Float.class)) return new Float(defaultNumValue);
      if (cl.equals(Double.class)) return new Double(defaultNumValue);
      
      // built-in axis supported classes (org.apache.axis.types) 
      // that cannot be constructed with default values
      if (cl.equals(org.apache.axis.types.NegativeInteger.class)){
        byte[] arr = {-1};
        return new org.apache.axis.types.NegativeInteger(arr);
      }
      // Notation
      if (cl.equals(org.apache.axis.types.PositiveInteger.class)){
        byte[] arr = {1};
        return new org.apache.axis.types.PositiveInteger(arr);
      }
      if (cl.equals(org.apache.axis.types.UnsignedLong.class)) // double constructor is buggy 
        return new org.apache.axis.types.UnsignedLong(defaultNumValue);
      if (cl.equals(org.apache.axis.types.URI.class)) 
        try{return new org.apache.axis.types.URI("http://www.example.com");}
        catch(MalformedURIException e){};
        
      // get index of constructor to be used
      int constructorsIndex = getConstructorIndex(cl, constructors);
      
      Class parameterTypes[] = constructors[constructorsIndex].getParameterTypes();
      Object[] args = new Object[parameterTypes.length];
      for (int j = 0; j < parameterTypes.length; ++j){
        args[j] = getNewInstance(parameterTypes[j]);
      }
      return constructors[constructorsIndex].newInstance(args);
    }
    catch(IllegalAccessException e){
      throw new JCowsException(Properties.getMessage("error.IllegalAccessException"), e);
    }
    catch(InstantiationException e){
      throw new JCowsException(Properties.getMessage("error.InstantiationException"), e);
    }
    catch(InvocationTargetException e){
      throw new JCowsException(Properties.getMessage("error.InvocationTargetException"), e);
    }
    catch(IllegalArgumentException e){
      throw new JCowsException(Properties.getMessage("error.IllegalArgumentException"), e);
    }
  }
  
  /**
   * Returns the index of the constructor be be used for the instantiation of
   * the {@link java.lang.Class Class}.
   * 
   * @param cl the {@link java.lang.Class Class} to be instantiated.
   * @param constructors all the class's constructors.
   * @return an the index of the constructor in the constructor array
   * @throws JCowsException
   */
  public int getConstructorIndex(Class cl, Constructor[] constructors)
      throws JCowsException {

    // take first if it is non-default constructor
    if (constructors[0].getParameterTypes().length > 0) return getConstructorIndex(
        cl, constructors, 0);

    // take first non-default constructor (if more than 1 available)
    if (constructors.length > 1) return getConstructorIndex(cl, constructors, 1);

    // by default take second available constructor
    // as mostly the first is the default constructor
    return getConstructorIndex(cl, constructors, 0);
  }

  
  /**
   * Checks if the desired index points to a constructor that may be used
   * for instantiation.<br/>
   * It checks if the desired constructor does not contain the class itself
   * as a parameter, which would lead to an infinite loop.
   * 
   * @param cl the {@link java.lang.Class Class} to be instantiated.
   * @param constructors all the class's constuctors.
   * @param index the desired constructor's index.
   * @return the index of the constructor in the constructor array.
   * @throws JCowsException
   */
  public int getConstructorIndex(Class cl, Constructor[] constructors,
      int index) throws JCowsException {
    // this means that we cannot find an appropriate constructor
    if (index > constructors.length) 
      throw new JCowsException(
          Properties.getMessage("error.noAppropriateConstructorFound", 
              new String[]{cl.getName()}));

    // try next constructor if current contains the class itself as parameter
    // (-> endless loop)
    for (Class param : constructors[index].getParameterTypes()) {
      if (param.equals(cl)) {
        return getConstructorIndex(cl, constructors, ++index);
      }
    }
    return index;
  }
}
